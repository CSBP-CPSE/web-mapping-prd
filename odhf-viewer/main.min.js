(function () {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  var Util =
  /*#__PURE__*/
  function () {
    function Util() {
      _classCallCheck(this, Util);
    }

    _createClass(Util, null, [{
      key: "Mixin",

      /**
      * Merges an object into another object. 
      *
      * Parameters :
      *	a : Object, the object that will receive the properties 
      *	b : Object, the object to merge into object A
      * Return : the modified Object
      */
      value: function Mixin(a, b) {
        for (var key in b) {
          if (b.hasOwnProperty(key)) a[key] = b[key];
        } // TODO : Why did I use arguments[0] instead of a?


        return arguments[0];
      }
      /**
      * Debounces a function. The function will be executed after a timeout 
      * unless the function is called again in which case, the timeout will
      * reset
      *
      * Parameters :
      *	delegate : Function, the Function to debounce
      *	threshold : Integer, the timeout length, in milliseconds
      * Return : Function, the debounced function
      */

    }, {
      key: "Debounce",
      value: function Debounce(delegate, threshold) {
        var timeout;
        return function debounced() {
          function delayed() {
            delegate.apply(this, arguments);
            timeout = null;
          }

          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(delayed.bind(this), threshold || 100);
        };
      }
      /**
      * Formats a String using substitute strings
      *
      * Parameters :
      *	str : String, the String to format
      *	subs : Array(String), An array of Strings to substitute into the String
      * Return : String, the formatted String
      */

    }, {
      key: "Format",
      value: function Format(str, subs) {
        if (!subs || subs.length == 0) return str;
        var s = str;

        for (var i = 0; i < subs.length; i++) {
          var reg = new RegExp("\\{" + i + "\\}", "gm");
          s = s.replace(reg, subs[i]);
        }

        return s;
      }
    }, {
      key: "FirstProperty",
      value: function FirstProperty(obj) {
        var props = Object.getOwnPropertyNames(obj);
        return obj[props[0]];
      }
    }, {
      key: "ParseCsv",
      value: function ParseCsv(csv) {
        return csv.trim().split(/\r\n|\n/).map(function (l) {
          return l.split(',');
        });
      }
    }, {
      key: "DisableFocusable",
      value: function DisableFocusable(nodes, disabled) {
        var focusable = ["button", "fieldset", "input", "optgroup", "option", "select", "textarea"];
        nodes.forEach(function (n) {
          var selection = n.querySelectorAll(focusable);
          if (selection.length == 0) return;

          for (var i = 0; i < selection.length; i++) {
            selection[i].disabled = disabled;
          }
        });
      }
    }]);

    return Util;
  }();

  var _nls = null;
  var _locale = null;
  var _templatables = {};

  var Core =
  /*#__PURE__*/
  function () {
    function Core() {
      _classCallCheck(this, Core);
    }

    _createClass(Core, null, [{
      key: "Nls",

      /**
      * Get a localized nls string ressource
      *
      * Parameters :
      *	id : String, the id of the nls ressource to retrieve
      *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
      *	locale : String, the locale for the nls ressource
      * Return : String, the localized nls string ressource
      */
      value: function Nls(id, subs, locale) {
        if (!this.nls) throw new Error("Nls content not set.");
        var itm = this.nls[id];
        if (!itm) throw new Error("Nls String '" + id + "' undefined.");
        var txt = itm[locale ? locale : this.locale];
        if (txt === undefined || txt === null) throw new Error("String does not exist for requested language.");
        return Util.Format(txt, subs);
      }
      /**
      * A convenience function to get a deffered object for asynchronous processing. 
      * Removes one level of nesting when working with promises
      *
      * Parameters :
      *	none
      * Return : Object, an object with a Resolve and Reject function
      *
      * { 
      *	promise: the promise object associated to the asynchronous process, 
      *	Resolve: a function to resolve the promise, 
      *	Reject: a function to reject the promise 
      * }
      */

    }, {
      key: "Defer",
      value: function Defer() {
        var defer = {};
        defer.promise = new Promise(function (resolve, reject) {
          defer.Resolve = function (result) {
            resolve({
              result: result
            });
          };

          defer.Reject = function (error) {
            reject({
              error: error
            });
          };
        });
        return defer;
      }
      /**
      * Get or set a templated class definition, this is required to nest Templated UI 
      * components within other Templated UI components.
      *
      * Parameters :
      *	id : String, the id of the templated class definition to get or set
      *	definition : Class, when specified, the class definition to set 
      * Return : Class, the class definition created  
      */

    }, {
      key: "Templatable",
      value: function Templatable(id, definition) {
        if (definition) {
          if (_templatables[id]) throw new Error("Templatable ".concat(id, " is defined multiple times."));else _templatables[id] = definition;
        } else if (!_templatables[id]) throw new Error("Templatable ".concat(id, " is not defined."));

        return _templatables[id];
      }
      /**
      * Get an Array of class definitions by matching its
      *
      * Parameters :
      *	id : String, the id of the nls ressource to retrieve
      *	subs : Array(String), an array of Strings to substitute in the localized nls string ressource
      *	locale : String, the locale for the nls ressource
      * Return : String, the localized nls string ressource
      */

    }, {
      key: "Templated",
      value: function Templated(namespace) {
        var templated = [];

        for (var id in _templatables) {
          if (id.match(namespace)) templated.push(_templatables[id]);
        }

        return templated;
      }
    }, {
      key: "nls",

      /**
      * Gets the nls ressources
      *
      * Return : Object, an object containing the nls ressources
      */
      get: function get() {
        return _nls;
      }
      /**
      * Sets the nls ressources
      */
      ,
      set: function set(value) {
        _nls = value;
      }
      /**
      * Gets the locale String
      *
      * Return : String, a String containing the locale
      */

    }, {
      key: "locale",
      get: function get() {
        return _locale;
      }
      /**
      * Sets the locale String
      */
      ,
      set: function set(value) {
        _locale = value;
      }
    }]);

    return Core;
  }();

  var Net =
  /*#__PURE__*/
  function () {
    function Net() {
      _classCallCheck(this, Net);
    }

    _createClass(Net, null, [{
      key: "Request",

      /**
      * Execute a web request
      *
      * Parameters :
      *	url : String, the request URL
      * Return : none
      *
      * TODO : This should return a promise object but (ie11)
      *
      */
      value: function Request(url) {
        var d = Core.Defer();
        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {
          if (this.readyState != 4) return; // TODO : Switched to this.response, check if it breaks anything

          if (this.status == 200) d.Resolve(this.response);else {
            var error = new Error(this.status + " " + this.statusText);
            d.Reject(error);
          }
        };

        xhttp.open("GET", url, true);
        xhttp.send();
        return d.promise;
      }
    }, {
      key: "JSON",
      value: function (_JSON) {
        function JSON(_x) {
          return _JSON.apply(this, arguments);
        }

        JSON.toString = function () {
          return _JSON.toString();
        };

        return JSON;
      }(function (url) {
        var d = Core.Defer();
        Net.Request(url).then(function (r) {
          return d.Resolve(JSON.parse(r.result));
        }, d.Reject);
        return d.promise;
      })
      /**
      * Get a parameter value from the document URL
      *
      * Parameters :
      *	name : String, the name of the parameter to retrieve from the URL
      * Return : String, the value of the parameter from the URL, an empty string if not found
      */

    }, {
      key: "GetUrlParameter",
      value: function GetUrlParameter(name) {
        name = name.replace(/[\[\]]/g, '\\$&');
        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        var results = regex.exec(window.location.href);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
      }
      /**
      * Download content as a file
      *
      * Parameters :
      *	name : String, the name of the file to download
      *	content : 
      * Return : none
      */

    }, {
      key: "Download",
      value: function Download(name, content) {
        var link = document.createElement("a");
        link.href = "data:application/octet-stream," + encodeURIComponent(content);
        link.download = name;
        link.click();
        link = null;
      }
      /**
      * Gets the base URL for the app
      *
      * Parameters : none
      * Return : String, the base path to the web app
      */

    }, {
      key: "AppPath",
      value: function AppPath() {
        var path = location.href.split("/");
        path.pop();
        return path.join("/");
      }
      /**
      * Gets the base URL for the app
      *
      * Parameters : none
      * Return : String, the base path to the web app
      */

    }, {
      key: "FilePath",
      value: function FilePath(file) {
        file = file.charAt(0) == "/" ? file.substr(1) : file;
        var path = [Net.AppPath(), file];
        return path.join("/");
      }
    }]);

    return Net;
  }();

  var Configuration =
  /*#__PURE__*/
  function () {
    _createClass(Configuration, [{
      key: "ID",
      // Get for untransformed properties
      get: function get() {
        return this.id;
      }
    }, {
      key: "Style",
      get: function get() {
        return this.style;
      } // Get for localized strings

    }, {
      key: "Title",
      get: function get() {
        return this.title;
      }
    }, {
      key: "Banner",
      get: function get() {
        return this.banner;
      }
    }, {
      key: "Subtitle",
      get: function get() {
        return this.subtitle;
      }
    }, {
      key: "Description",
      get: function get() {
        return this.description;
      }
    }, {
      key: "Layers",
      get: function get() {
        return this.layers;
      } // Get for transformed properties

    }, {
      key: "LayerIDs",
      get: function get() {
        var layers = this.Layers;
        return layers && layers.map(function (l) {
          return l.id;
        });
      }
    }, {
      key: "VisibleLayers",
      get: function get() {
        var layers = this.Layers;
        return layers && layers.filter(function (l) {
          return l.visible || l.visible === undefined;
        });
      }
    }, {
      key: "VisibleLayerIDs",
      get: function get() {
        var layers = this.VisibleLayers;
        return layers && layers.map(function (l) {
          return l.id;
        });
      }
    }, {
      key: "SelectedLayers",
      get: function get() {
        var layers = this.Layers;
        return layers.filter(function (l) {
          return l.selected;
        });
      }
    }, {
      key: "SelectedLayerIDs",
      get: function get() {
        var layers = this.SelectedLayers;
        return layers && layers.map(function (l) {
          return l.id;
        });
      }
    }, {
      key: "Legend",
      get: function get() {
        return this.legend && this.legend.map(function (l) {
          return {
            color: l.color,
            label: l.label && l.label[Core.locale],
            value: l.value
          };
        });
      }
    }, {
      key: "TOC",
      get: function get() {
        return this.toc && this.toc.map(function (t) {
          return {
            id: t.id,
            label: t.label && t.label[Core.locale]
          };
        });
      }
    }, {
      key: "Fields",
      get: function get() {
        return this.fields && this.fields.map(function (f) {
          return {
            id: f.id,
            label: f.label && f.label[Core.locale],
            polish: f.polish || null
          };
        });
      }
    }]);

    function Configuration() {
      _classCallCheck(this, Configuration);

      this.id = null;
      this.style = null;
      this.layers = null;
      this.title = null;
      this.banner = null;
      this.subtitle = null;
      this.description = null;
      this.legend = null;
      this.toc = null;
      this.fields = null;
    }

    _createClass(Configuration, [{
      key: "HasLayer",
      value: function HasLayer(layerId) {
        for (var i = 0; i < this.layers.length; i++) {
          if (this.layers[i].id === layerId) return true;
        }

        return false;
      }
    }], [{
      key: "FromJSON",
      value: function FromJSON(json) {
        var c = new Configuration();
        c.id = json.id;
        c.style = json.style;
        c.title = json.title && json.title[Core.locale] || null;
        c.banner = json.banner && json.banner[Core.locale] || null;
        c.subtitle = json.subtitle && json.subtitle[Core.locale] || null;
        c.description = json.description && json.description[Core.locale] || null;
        c.layers = json.layers || null;
        c.legend = json.legend || null;
        c.toc = json.toc || null;
        c.fields = json.fields || null;
        return c;
      }
    }]);

    return Configuration;
  }();

  var Other =
  /*#__PURE__*/
  function () {
    function Other() {
      _classCallCheck(this, Other);
    }

    _createClass(Other, null, [{
      key: "Polish",
      value: function Polish(json, exp, d) {
        // exp is formatted as follows [symbol, property 1, property 2]
        var v1 = json[exp[1]];
        var v2 = json[exp[2]];
        var v = null;
        if (exp[0] == "+") v = v1 + v2;
        if (exp[0] == "-") v = v1 - v2;
        if (exp[0] == "*") v = v1 * v2;
        if (exp[0] == "/") v = v1 / v2;
        return v.toFixed(d);
      }
    }, {
      key: "HTMLize",
      value: function HTMLize(json, fields, na) {
        var html = "";
        fields.forEach(function (f) {
          var label = f.label;
          var value = na;

          if (json.hasOwnProperty(f.id) || f.polish) {
            value = f.polish ? Other.Polish(json, f.polish, 2) : json[f.id];
            if (f.fixed) value = value.toFixed(f.fixed);
          }

          html += "<div class='row'><span>".concat(label, " : </span><span>").concat(value, "</span></div>");
        });
        return "<div class='popup-inner'>".concat(html, "</div>");
      }
    }]);

    return Other;
  }();

  var Dom =
  /*#__PURE__*/
  function () {
    function Dom() {
      _classCallCheck(this, Dom);
    }

    _createClass(Dom, null, [{
      key: "Node",

      /**
      * Retrieve an Element using a selector
      *
      * Parameters :
      *	pNode : Element, the parent node where to begin the search
      *	selector : String, a selector statement
      * Return : Element, the Element found, null otherwise
      */
      value: function Node(pNode, selector) {
        return pNode.querySelectorAll(selector).item(0) || null;
      }
      /**
      * Create an Element
      *
      * Parameters :
      *	tagName : String, the type of Element to be created (div, span, label, input, etc.)
      *	options : Object, a dictionary type object containing the options to assign to the created Element
      *	pNode : Element, the parent Element where the created Element will be apended
      * Return : Element, The Element created
      */

    }, {
      key: "Create",
      value: function Create(tagName, options, pNode) {
        var elem = document.createElement(tagName);
        Util.Mixin(elem, options);
        this.Place(elem, pNode);
        return elem;
      }
      /**
      * Create an SVG Element
      *
      * Parameters :
      *	tagName : String, the type of SVG Element to be created (rect, path, etc.)
      *	options : Object, a dictionary type object containing the options to assign to the created SVG Element
      *	pNode : Element, the parent Element where the created SVG Element will be apended
      * Return : Element, The SVG Element created
      */

    }, {
      key: "CreateSVG",
      value: function CreateSVG(tagName, options, pNode) {
        var elem = document.createElementNS("http://www.w3.org/2000/svg", tagName);

        for (var id in options) {
          elem.setAttribute(id, options[id]);
        }

        this.Place(elem, pNode);
        return elem;
      }
      /**
      * Create an Element from a namespace
      *
      * Parameters :
      *	ns : String, the URI namespace containing the Element to create 
      *	tagName : String, the type of Element to be created (rect, path, etc.)
      *	options : Object, a dictionary type object containing the options to assign to the created Element
      *	pNode : Element, the parent Element where the created Element will be apended
      *
      * Valid Namespaces are : 
      *	HTML : http://www.w3.org/1999/xhtml
      *	SVG  : http://www.w3.org/2000/svg
      *	XBL  : http://www.mozilla.org/xbl
      *	XUL  : http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul
      *
      * Return : Element, The SVG Element created
      */

    }, {
      key: "CreateNS",
      value: function CreateNS(ns, tagName, options, pNode) {
        var elem = document.createElementNS(ns, tagName);

        for (var id in options) {
          elem.setAttribute(id, options[id]);
        }

        this.Place(elem, pNode);
        return elem;
      }
      /**
      * Append an Element to another Element
      *
      * Parameters :
      *	elem : Element, the Element to append
      *	pNode : Element, the parent Element where the Element will be apended
      * Return : none
      */

    }, {
      key: "Place",
      value: function Place(elem, pNode) {
        if (!!pNode) pNode.appendChild(elem);
      }
      /**
      * Replace an Element by another Element
      *
      * Parameters :
      *	elem1 : Element, the Element to be replaced
      *	elem2 : Element, the Element that will replace elem1
      * Return : none
      */

    }, {
      key: "Replace",
      value: function Replace(elem1, elem2) {
        var pNode = elem1.parentNode;
        pNode.insertBefore(elem2, elem1);
        this.Remove(elem1, pNode);
      }
      /**
      * Remove an Element from another Element
      *
      * Parameters :
      *	elem : Element, the Element to remove
      *	pNode : Element, the parent Element containing the Element to remove
      * Return : none
      */

    }, {
      key: "Remove",
      value: function Remove(elem, pNode) {
        if (!pNode.children.some(function (child) {
          return child === elem;
        })) return;
        pNode.removeChild(elem);
      }
      /**
      * Remove all children of an Element
      *
      * Parameters :
      *	elem : Element, the Element to empty
      * Return : none
      */

    }, {
      key: "Empty",
      value: function Empty(elem) {
        while (elem.firstChild) {
          elem.removeChild(elem.firstChild);
        }
      }
      /**
      * Add a CSS rule on an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to add on the Element
      * Return : none
      */

    }, {
      key: "AddCss",
      value: function AddCss(elem, css) {
        var c1 = elem.className.split(" ");
        css.split(" ").forEach(function (c) {
          if (c1.indexOf(c) == -1) c1.push(c);
        });
        elem.className = c1.join(" ");
      }
      /**
      * Remove a CSS rule on an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to remove from the Element
      * Return : none
      */

    }, {
      key: "RemoveCss",
      value: function RemoveCss(elem, css) {
        var c1 = elem.className.split(" ");
        var c2 = css.split(" ");
        elem.className = c1.filter(function (c) {
          return c2.indexOf(c) == -1;
        }).join(" ");
      }
      /**
      * Verify that an Element contains a CSS rule
      *
      * Parameters :
      *	elem : Element, the Element to verify
      *	css : String, the CSS rule to find
      * Return : Boolean, true if the Element contains the CSS rule, false otherwise
      */

    }, {
      key: "HasCss",
      value: function HasCss(elem, css) {
        return (' ' + elem.className + ' ').indexOf(' ' + css + ' ') > -1;
      }
      /**
      * Set the CSS rules on an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to set on the Element
      * Return : none
      */

    }, {
      key: "SetCss",
      value: function SetCss(elem, css) {
        elem.className = css;
      }
      /**
      * Toggle a CSS rule on or or off for an Element
      *
      * Parameters :
      *	elem : Element, the Element to modify
      *	css : String, the CSS rule to toggle on the Element
      *	enabled : Boolean, true to toggle the CSS rule on, false to toggle it off
      * Return : none
      */

    }, {
      key: "ToggleCss",
      value: function ToggleCss(elem, css, enabled) {
        if (enabled) this.AddCss(elem, css);else this.RemoveCss(elem, css);
      }
      /**
      * Get an attribute value from an Element
      *
      * Parameters :
      *	elem : Element, the Element to retrieve the attribute from
      *	attr : String, the name of the attribute to retrieve
      * Return : String, the value of the attribute if found, null otherwise
      */

    }, {
      key: "GetAttribute",
      value: function GetAttribute(elem, attr) {
        var attr = elem.attributes.getNamedItem(attr);
        return attr ? attr.value : null;
      }
      /**
      * Set an attribute value on an Element
      *
      * Parameters :
      *	elem : Element, the Element to set the attribute on
      *	attr : String, the name of the attribute to set
      *	value : String, the value of the attribute to set
      * Return : none
      */

    }, {
      key: "SetAttribute",
      value: function SetAttribute(elem, attr, value) {
        elem.setAttribute(attr, value);
      }
      /**
      * Get the size of an Element
      *
      * Parameters :
      *	elem : Element, the Element to retrieve the size
      * Return : Object, an object literal containing the size of the Element
      * 
      * { 
      *	w: width of the Element, 
      *	h: height of the Element 
      * }
      */

    }, {
      key: "Size",
      value: function Size(elem) {
        var style = window.getComputedStyle(elem);
        var h = +style.getPropertyValue("height").slice(0, -2);
        var w = +style.getPropertyValue("width").slice(0, -2);
        var pL = +style.getPropertyValue("padding-left").slice(0, -2);
        var pR = +style.getPropertyValue("padding-right").slice(0, -2);
        var pT = +style.getPropertyValue("padding-top").slice(0, -2);
        var pB = +style.getPropertyValue("padding-bottom").slice(0, -2);
        var w = w - pL - pR;
        var h = h - pT - pB; // Use smallest width as width and height for square grid that fits in container
        // var s = w <Â h ? w : h;

        return {
          w: w,
          h: h
        };
      }
      /**
      * Get the siblings of an Element
      *
      * Parameters :
      *	elem : Element, the Element to retrieve the siblings
      * Return : Array, An array of elements containing the siblings of the input element
      */

    }, {
      key: "Siblings",
      value: function Siblings(elem) {
        var elements = [];

        for (var i = 0; i < elem.parentNode.children.length; i++) {
          elements.push(elem.parentNode.children[i]);
        }

        elements.splice(elements.indexOf(elem), 1);
        return elements;
      }
    }]);

    return Dom;
  }();

  var Evented =
  /*#__PURE__*/
  function () {
    function Evented() {
      _classCallCheck(this, Evented);

      this.listeners = {};
    }

    _createClass(Evented, [{
      key: "addEventListener",
      value: function addEventListener(type, callback, once) {
        if (!(type in this.listeners)) this.listeners[type] = [];
        var h = {
          target: this,
          type: type,
          callback: callback,
          once: !!once
        };
        this.listeners[type].push(h);
        return h;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        if (!(type in this.listeners)) return;
        var stack = this.listeners[type];

        for (var i = 0, l = stack.length; i < l; i++) {
          if (stack[i].callback === callback) {
            stack.splice(i, 1);
            return this.removeEventListener(type, callback);
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (!(event.type in this.listeners)) return;
        var stack = this.listeners[event.type];

        for (var i = 0; i < stack.length; i++) {
          stack[i].callback.call(this, event);
        }

        for (var i = stack.length - 1; i >= 0; i--) {
          if (!!stack[i].once) this.removeEventListener(event.type, stack[i].callback);
        }
      }
    }, {
      key: "Emit",
      value: function Emit(type, data) {
        // Let base event properties be overwritten by whatever was provided.	
        var event = {
          bubbles: true,
          cancelable: true
        };
        Util.Mixin(event, data); // Use the type that was specifically provided, target is always this.

        event.type = type;
        event.target = this;
        this.dispatchEvent(event);
      }
    }, {
      key: "On",
      value: function On(type, callback) {
        return this.addEventListener(type, callback, false);
      }
    }, {
      key: "Once",
      value: function Once(type, callback) {
        return this.addEventListener(type, callback, true);
      }
    }, {
      key: "Off",
      value: function Off(type, callback) {
        this.removeEventListener(type, callback);
      }
    }]);

    return Evented;
  }();

  var Templated =
  /*#__PURE__*/
  function (_Evented) {
    _inherits(Templated, _Evented);

    function Templated(container, options) {
      var _this;

      _classCallCheck(this, Templated);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Templated).call(this));
      _this.options = options || {};

      _this.BuildTemplate();

      if (_this.template) _this.SetNamedNodes();
      if (_this.template) _this.BuildSubWidgets();
      if (container) _this.Place(container);
      return _this;
    }

    _createClass(Templated, [{
      key: "BuildTemplate",
      value: function BuildTemplate() {
        // Use template provided in options first, use Template function second
        var html = this.options.template ? this.options.template : this.Template(); // TODO : I think it still works with empty templates.

        if (!html) return; // Trailing whitespaces can cause issues when parsing the template, remove them

        html = html.trim(); // Replace all nls strings in template. Nls string pattern in templates is nls(StringId)

        html = this.Replace(html, /nls\((.*?)\)/, function (m) {
          return Core.Nls(m);
        });
        this.template = Dom.Create("div", {
          innerHTML: html
        });
      }
    }, {
      key: "SetNamedNodes",
      value: function SetNamedNodes() {
        var named = this.template.querySelectorAll("[handle]");
        this.nodes = {}; // Can't use Array ForEach here since named is a NodeList, not an array

        for (var i = 0; i < named.length; i++) {
          var name = Dom.GetAttribute(named[i], "handle");
          this.nodes[name] = named[i];
        }
      }
    }, {
      key: "BuildSubWidgets",
      value: function BuildSubWidgets() {
        var nodes = this.template.querySelectorAll("[widget]");

        for (var i = 0; i < nodes.length; i++) {
          var path = Dom.GetAttribute(nodes[i], "widget");
          var module = Core.Templatable(path);
          var widget = new module(nodes[i]);
          var handle = Dom.GetAttribute(widget.container, "handle");
          if (handle) this.nodes[handle] = widget;
        }
      }
    }, {
      key: "Place",
      value: function Place(container) {
        this.container = container;
        if (!this.template) return;

        while (this.template.children.length > 0) {
          Dom.Place(this.template.children[0], this.container);
        }
      }
    }, {
      key: "Template",
      value: function Template() {
        return null;
      }
    }, {
      key: "Replace",
      value: function Replace(str, expr, delegate) {
        var m = str.match(expr);

        while (m) {
          str = str.replace(m[0], delegate(m[1]));
          m = str.match(expr);
        }

        return str;
      }
    }, {
      key: "Node",
      value: function Node(id) {
        return this.nodes[id];
      } // TODO : Build a root function

    }]);

    return Templated;
  }(Evented);

  var Control =
  /*#__PURE__*/
  function (_Templated) {
    _inherits(Control, _Templated);

    function Control(options) {
      var _this;

      _classCallCheck(this, Control);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Control).call(this, null, options));
      if (!_this.template) throw new Error("MapBox controls cannot be empty");
      if (_this.template.children.length > 1) throw new Error("MapBox controls should have one root node");
      _this._container = _this.template.children[0];
      return _this;
    }

    _createClass(Control, [{
      key: "onAdd",
      value: function onAdd(map) {
        this._map = map;
        return this._container;
      }
    }, {
      key: "onRemove",
      value: function onRemove() {
        this._container.parentNode.removeChild(this._container);

        this._map = undefined;
      }
    }]);

    return Control;
  }(Templated);

  var Legend =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Legend, _Control);

    function Legend(options) {
      var _this;

      _classCallCheck(this, Legend);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Legend).call(this, options));
      _this._container = _this.Node('root');

      _this.Reload(options.legend, options.title, options.banner, options.subtitle);

      return _this;
    }

    _createClass(Legend, [{
      key: "Reload",
      value: function Reload(legend, title, banner, subtitle) {
        this.LoadLegend(legend);
        if (banner) this.Node('banner').innerHTML = banner;
        if (title) this.Node('title').innerHTML = title;
        if (subtitle) this.Node('subtitle').innerHTML = subtitle;
        Dom.ToggleCss(this.Node("banner"), "hidden", !banner);
        Dom.ToggleCss(this.Node("title"), "hidden", !title);
        Dom.ToggleCss(this.Node("subtitle"), "hidden", !subtitle);
      }
    }, {
      key: "LoadLegend",
      value: function LoadLegend(config) {
        var _this2 = this;

        Dom.Empty(this.Node("legend"));
        if (!config) return;
        config.forEach(function (i) {
          return _this2.AddLegendItem(i);
        });
      }
    }, {
      key: "AddLegendItem",
      value: function AddLegendItem(item) {
        if (!item.label) return;
        var div = Dom.Create("div", {
          className: "legend-item legend-item-1"
        }, this.Node("legend"));
        var icn = Dom.Create("div", {
          className: "legend-icon"
        }, div);
        var lbl = Dom.Create("div", {
          innerHTML: item.label
        }, div);
        icn.style.backgroundColor = "rgb(".concat(item.color.join(","), ")");
        icn.style.border = "solid thin silver";
        return div;
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='legend mapboxgl-ctrl'>" + "<div handle='banner' class='control-label legend-banner'></div>" + "<div>" + "<div handle='title' class='control-label'></div>" + "<div handle='subtitle' class='control-label legend-subtitle'></div>" + "</div>" + "<div handle='legend' class='legend-container'></div>" + "</div>";
      }
    }]);

    return Legend;
  }(Control);

  var Toc =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Toc, _Control);

    function Toc(options) {
      var _this;

      _classCallCheck(this, Toc);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Toc).call(this, options));
      _this._container = _this.Node('root');

      _this.Reload(options.toc);

      return _this;
    }

    _createClass(Toc, [{
      key: "HasLayer",
      value: function HasLayer(layerId) {
        return this.radios.hasOwnProperty(layerId);
      }
    }, {
      key: "Reload",
      value: function Reload(toc) {
        var _this2 = this;

        Dom.Empty(this.Node("toc"));
        this.radios = {};
        if (toc) toc.forEach(function (i) {
          return _this2.radios[i.id] = _this2.AddTocItem(i);
        });
      }
    }, {
      key: "SelectItem",
      value: function SelectItem(selected) {
        if (this.current) this.radios[this.current].checked = false;
        if (!this.HasLayer(selected)) return;
        this.current = selected;
        this.radios[selected].checked = true;
      }
    }, {
      key: "onChange_Handler",
      value: function onChange_Handler(item, ev) {
        if (this.current) this.radios[this.current].checked = false;
        this.current = item.id;
        this.Emit('LayerVisibility', {
          layer: this.current
        });
      }
    }, {
      key: "AddTocItem",
      value: function AddTocItem(item) {
        var i = this.Node("toc").children.length + 1;
        var div = Dom.Create("div", {
          className: "toc-item"
        }, this.Node("toc"));
        var ipt = Dom.Create("input", {
          type: "radio",
          name: "toc",
          id: "rd-".concat(i)
        }, div);
        var lbl = Dom.Create("label", {
          innerHTML: item.label
        }, div);
        lbl.setAttribute("for", "rd-".concat(i));
        ipt.addEventListener('change', this.onChange_Handler.bind(this, item));
        return ipt;
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='toc mapboxgl-ctrl'>" + "<div class='control-label'>nls(Toc_Instruction)</div>" + "<div handle='toc' class='legend-container toc-container'></div>" + "</div>";
      }
    }]);

    return Toc;
  }(Control);

  var Legend$1 =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Legend, _Control);

    _createClass(Legend, [{
      key: "title",
      set: function set(value) {
        this.Node("slider").title = value;
      }
    }]);

    function Legend(options) {
      var _this;

      _classCallCheck(this, Legend);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Legend).call(this, options));
      _this._container = _this.Node('root');
      _this.opacity = _this.options.opacity == undefined ? 0.75 : _this.options.opacity;
      _this.Node("slider").value = _this.opacity * 100;

      _this.Node('slider').addEventListener("change", _this.onSliderChange_Handler.bind(_assertThisInitialized(_this)));

      return _this;
    }

    _createClass(Legend, [{
      key: "onSliderChange_Handler",
      value: function onSliderChange_Handler(ev) {
        this.opacity = this.Node("slider").value / 100;
        this.Emit("OpacityChanged", {
          opacity: this.opacity
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='opacity mapboxgl-ctrl'>" + "<div class='control-label'>nls(Toc_Opacity)</div>" + "<div class='opacity-slider'>" + "<input handle='slider' type='range' min='0' max='100' value='75' class='slider'>" + "</div>" + "</div>";
      }
    }]);

    return Legend;
  }(Control);

  var Download =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Download, _Control);

    function Download(options) {
      var _this;

      _classCallCheck(this, Download);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Download).call(this, options));
      _this._container = _this.Node('root');
      if (options.link) _this.Node('link').setAttribute('href', options.link);
      return _this;
    }

    _createClass(Download, [{
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='download mapboxgl-ctrl'>" + "<div class='control-label'>" + "<a handle='link' class='link'>nls(Download_Title)</a>" + "</div>" + "</div>";
      }
    }]);

    return Download;
  }(Control);

  var Tooltip =
  /*#__PURE__*/
  function (_Templated) {
    _inherits(Tooltip, _Templated);

    _createClass(Tooltip, [{
      key: "BBox",
      get: function get() {
        return this.Node("root").getBoundingClientRect();
      }
    }]);

    function Tooltip(css) {
      var _this;

      _classCallCheck(this, Tooltip);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Tooltip).call(this, document.body));
      if (css) Dom.AddCss(_this.Node("root"), css);
      return _this;
    }

    _createClass(Tooltip, [{
      key: "Template",
      value: function Template() {
        return '<div handle="root" class="tooltip">' + '<div handle="content"></div>' + '</div>';
      }
    }, {
      key: "PositionTarget",
      value: function PositionTarget(target, offset) {
        offset = offset || [0, 0];
        bbox1 = target.getBoundingClientRect();
        bbox2 = this.Node("root").getBoundingClientRect();
        var x = bbox1.left + bbox1.width / 2 - bbox2.width / 2 + offset[0];
        var y = bbox1.top + document.documentElement.scrollTop - bbox2.height - 5 + offset[1];
        this.PositionXY(x, y);
      }
    }, {
      key: "PositionXY",
      value: function PositionXY(x, y) {
        this.Node("root").style.left = x + "px";
        this.Node("root").style.top = y + "px";

        if (this.BBox.left + this.BBox.width > window.innerWidth) {
          this.Node("root").style.top = y + 30 + "px";
          this.Node("root").style.left = -180 + x + "px";
        }
      }
    }, {
      key: "Show",
      value: function Show(x, y) {
        this.PositionXY(x, y);
        this.Node("root").style.opacity = 1;
      }
    }, {
      key: "Hide",
      value: function Hide() {
        this.Node("root").style.opacity = 0;
      }
    }, {
      key: "Empty",
      value: function Empty() {
        Dom.Empty(this.Node("content"));
      }
    }]);

    return Tooltip;
  }(Templated);

  var MapsList =
  /*#__PURE__*/
  function (_Control) {
    _inherits(MapsList, _Control);

    function MapsList(options) {
      var _this;

      _classCallCheck(this, MapsList);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MapsList).call(this, options));
      _this._container = _this.Node('root');
      _this.tooltip = new Tooltip();

      for (var id in options.maps) {
        _this.AddMapItem(id, options.maps[id]);
      }

      return _this;
    }

    _createClass(MapsList, [{
      key: "AddMapItem",
      value: function AddMapItem(id, map) {
        var li = Dom.Create('li', {
          className: "maps-list-item",
          innerHTML: map.title,
          tabIndex: 0
        }, this.Node("ul"));
        li.addEventListener("mousemove", this.OnLiMouseMove_Handler.bind(this, id, map));
        li.addEventListener("mouseleave", this.OnLiMouseLeave_Handler.bind(this, id, map));
        li.addEventListener("click", this.OnLiClick_Handler.bind(this, id, map));
        li.addEventListener("keydown", this.OnLiKeydown_Handler.bind(this, id, map));
      }
    }, {
      key: "OnLiMouseMove_Handler",
      value: function OnLiMouseMove_Handler(id, map, ev) {
        this.tooltip.Node("content").innerHTML = map.description;
        this.tooltip.Show(ev.x + 20, ev.y);
      }
    }, {
      key: "OnLiMouseLeave_Handler",
      value: function OnLiMouseLeave_Handler(id, map, ev) {
        this.tooltip.Hide();
      }
    }, {
      key: "OnLiKeydown_Handler",
      value: function OnLiKeydown_Handler(id, map, ev) {
        // prevent default event on specifically handled keys
        if (ev.keyCode != 13) return;
        ev.preventDefault();
        this.Emit("MapSelected", {
          id: id,
          map: map
        });
      }
    }, {
      key: "OnLiClick_Handler",
      value: function OnLiClick_Handler(id, map, ev) {
        this.Emit("MapSelected", {
          id: id,
          map: map
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='maps'>" + "<div class='maps-header-container'>" + "<img class='maps-header-icon' src='assets/layers.png'></img>" + "<h2 class='maps-header'>nls(Maps_Header)</h2>" + "</div>" + "<ul handle='ul' class='maps-list'></ul>" + "<div handle='description' class='maps-description'>nls(Maps_Description)</div>" + "</div>";
      }
    }]);

    return MapsList;
  }(Control);

  var Bookmarks =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Bookmarks, _Control);

    function Bookmarks(options) {
      var _this;

      _classCallCheck(this, Bookmarks);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Bookmarks).call(this, options));
      _this._container = _this.Node('root');
      if (!options.items) return _possibleConstructorReturn(_this);
      options.items = options.items.sort(function (a, b) {
        if (a.label < b.label) return -1;
        if (a.label > b.label) return 1;
        return 0;
      });
      options.items.forEach(function (i) {
        _this.AddBookmark(i);
      });
      return _this;
    }

    _createClass(Bookmarks, [{
      key: "AddBookmark",
      value: function AddBookmark(item) {
        var li = Dom.Create('li', {
          className: "bookmarks-list-item",
          innerHTML: item.label,
          tabIndex: 0
        }, this.Node("ul"));
        li.addEventListener("keydown", this.OnLiKeydown_Handler.bind(this, item));
        li.addEventListener("click", this.OnLiClick_Handler.bind(this, item));
      }
    }, {
      key: "OnLiKeydown_Handler",
      value: function OnLiKeydown_Handler(item, ev) {
        if (ev.keyCode != 13) return;
        ev.preventDefault();
        this.Emit("BookmarkSelected", {
          item: item
        });
      }
    }, {
      key: "OnLiClick_Handler",
      value: function OnLiClick_Handler(item, ev) {
        this.Emit("BookmarkSelected", {
          item: item
        });
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='bookmarks'>" + "<div class='bookmarks-header-container'>" + "<img class='bookmarks-header-icon' src='assets/bookmarks.png'></img>" + "<h2 class='bookmarks-header'>nls(Bookmarks_Header)</h2>" + "</div>" + "<ul handle='ul' class='bookmarks-list'></ul>" + "<div handle='description' class='bookmarks-description'>nls(Bookmarks_Description)</div>" + "</div>";
      }
    }]);

    return Bookmarks;
  }(Control);

  Core.Templatable("Basic.Components.Typeahead",
  /*#__PURE__*/
  function (_Templated) {
    _inherits(Typeahead, _Templated);

    _createClass(Typeahead, [{
      key: "placeholder",
      set: function set(value) {
        this.Node('input').setAttribute('placeholder', value);
      }
    }, {
      key: "title",
      set: function set(value) {
        this.Node('input').setAttribute('title', value);
      }
    }, {
      key: "items",
      set: function set(value) {
        var _this2 = this;

        this._items = value.map(function (i) {
          var li = Dom.Create("li", {
            innerHTML: i.label,
            tabIndex: -1
          });
          var item = {
            data: i,
            node: li
          };
          li.addEventListener("mousedown", _this2.onLiClick_Handler.bind(_this2, item));
          return item;
        });
      }
    }, {
      key: "current",
      set: function set(value) {
        this._curr = value;
      },
      get: function get() {
        return this._curr;
      }
    }]);

    function Typeahead(container, options) {
      var _this;

      _classCallCheck(this, Typeahead);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Typeahead).call(this, container, options));
      _this._items = null;
      _this._filt = null;
      _this._curr = null;
      _this._temp = null;

      _this.Node("input").addEventListener("input", function (ev) {
        this.OnInputInput_Handler(ev);
      }.bind(_assertThisInitialized(_this))); // this.Node("input").addEventListener("click", this.OnInputClick_Handler.bind(this));


      _this.Node("input").addEventListener("keydown", function (ev) {
        this.OnInputKeyDown_Handler(ev);
      }.bind(_assertThisInitialized(_this)));

      _this.Node("input").addEventListener("blur", function (ev) {
        this.OnInputBlur_Handler(ev);
      }.bind(_assertThisInitialized(_this)));

      _this.Node("input").addEventListener("focusin", function (ev) {
        this.OnInputClick_Handler(ev);
      }.bind(_assertThisInitialized(_this))); // this.Node("input").addEventListener("focusout", this.OnInputBlur_Handler.bind(this));


      if (!options) return _possibleConstructorReturn(_this);
      _this.items = options.items;
      return _this;
    }

    _createClass(Typeahead, [{
      key: "Empty",
      value: function Empty() {
        Dom.Empty(this.Node("list"));
        this._filt = [];
      }
    }, {
      key: "Fill",
      value: function Fill(mask) {
        this._filt = this._items.filter(function (i) {
          return compare(i.data.label, mask);
        });
        var frag = document.createDocumentFragment();

        for (var i = 0; i < this._filt.length; i++) {
          var curr = this._filt[i]; // Maybe insert <b> at right index instead, faster?

          curr.node.innerHTML = curr.data.label.replace(mask, "<b>".concat(mask, "</b>"));
          curr.next = this._filt[(i + 1) % this._filt.length];
          curr.next.prev = curr;
          Dom.Place(curr.node, frag);
        }

        Dom.Place(frag, this.Node("list"));

        function compare(label, mask) {
          return label.toLowerCase().indexOf(mask.toLowerCase()) !== -1;
        }
      }
    }, {
      key: "UpdateCss",
      value: function UpdateCss() {
        Dom.ToggleCss(this.Node("root"), "collapsed", this._filt.length == 0);
      }
    }, {
      key: "Reset",
      value: function Reset() {
        if (this._temp) Dom.SetCss(this._temp.node, "");
        this._temp = null;
        this.Empty();
        var value = this.current ? this.current.data.label : "";
        this.Node("input").value = value;
      }
    }, {
      key: "OnInputInput_Handler",
      value: function OnInputInput_Handler(ev) {
        if (ev.target.value.length < 3) return;
        this.Empty();
        this.Fill(ev.target.value);
        this.UpdateCss();
      }
    }, {
      key: "OnInputClick_Handler",
      value: function OnInputClick_Handler(ev) {
        if (ev.target.value.length < 3) return;
        this.Fill(ev.target.value);
        this.UpdateCss();
      }
    }, {
      key: "OnInputKeyDown_Handler",
      value: function OnInputKeyDown_Handler(ev) {
        // prevent default event on specifically handled keys
        if (ev.keyCode == 40 || ev.keyCode == 38 || ev.keyCode == 13 || ev.keyCode == 27) ev.preventDefault(); // shift + up : select text

        if (ev.shiftKey == true && ev.keyCode == 38) this.nodes.Input.select(); // up or down key : cycle through dropdown
        else if (ev.keyCode == 40 || ev.keyCode == 38) {
            this._temp = this._temp || this._filt[this._filt.length - 1];
            Dom.SetCss(this._temp.node, "");
            this._temp = ev.keyCode == 40 ? this._temp.next : this._temp.prev;
            this.Node("input").value = this._temp.data.label;
            this.ScrollTo(this._temp);
            Dom.SetCss(this._temp.node, "active");
          } // enter : select currently focused
          else if (ev.keyCode == 13) {
              // if an item is currently selected through arrows, select that one
              if (this._temp) this.onLiClick_Handler(this._temp); // if a filtered list is being shown, select the first item
              else if (this._filt.length > 0) this.onLiClick_Handler(this._filt[0]); // nothing is selected (don't think this can happen		    	
                else {
                    this.OnInputClick_Handler({
                      target: this.Node("input")
                    });
                  }
            } // if escape key
            else if (ev.keyCode == 27) this.OnInputBlur_Handler();
      }
    }, {
      key: "OnInputBlur_Handler",
      value: function OnInputBlur_Handler(ev) {
        this.Reset();
        this.UpdateCss();
      }
    }, {
      key: "onLiClick_Handler",
      value: function onLiClick_Handler(item, ev) {
        this.current = item;
        this.Reset();
        this.UpdateCss();
        this.Emit("Change", {
          item: item.data
        });
      }
    }, {
      key: "ScrollTo",
      value: function ScrollTo(item) {
        // create rectangules to know the position of the elements
        var ul = this.Node("list");
        var liBx = item.node.getBoundingClientRect();
        var ulBx = ul.getBoundingClientRect(); //if the element is in this range then it is inside the main container, don't scroll

        if (liBx.bottom > ulBx.bottom) ul.scrollTop = ul.scrollTop + liBx.bottom - ulBx.top - ulBx.height;else if (liBx.top < ulBx.top) ul.scrollTop = ul.scrollTop + liBx.top - ulBx.top;
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='typeahead collapsed'>" + "<input handle='input' type='text' class='input'>" + "<ul handle='list' class='list'></ul>" + "</div>";
      }
    }]);

    return Typeahead;
  }(Templated));

  var Search =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Search, _Control);

    function Search(options) {
      var _this;

      _classCallCheck(this, Search);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Search).call(this, options));
      _this._container = _this.Node('root');
      _this.layer = options.layer;
      _this.field = options.field;
      _this.color = options.color; // TODO : This should probably happen outside of the widget.

      _this.Node('typeahead').items = _this.Itemize(options.items);
      _this.Node('typeahead').placeholder = options.placeholder;
      _this.Node('typeahead').title = options.title;

      _this.Node('typeahead').On('Change', _this.onTypeaheadChange_Handler.bind(_assertThisInitialized(_this)));

      return _this;
    }

    _createClass(Search, [{
      key: "Itemize",
      value: function Itemize(data) {
        var items = data.map(function (i) {
          return {
            id: i[0],
            label: "(".concat(i[0], ") ").concat(i[1]),
            extent: [[i[2], i[3]], [i[4], i[5]]]
          };
        });
        return items.sort(function (a, b) {
          return a.label > b.label ? 1 : -1;
        });
      }
    }, {
      key: "onTypeaheadChange_Handler",
      value: function onTypeaheadChange_Handler(ev) {
        var data = {
          layer: this.layer,
          field: this.field,
          color: this.color,
          item: ev.item
        };
        this.Emit('Change', data);
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='search-control mapboxgl-ctrl'>" + "<div handle='typeahead' widget='Basic.Components.Typeahead'></div>" + "</div>";
      }
    }]);

    return Search;
  }(Control);

  var Fullscreen =
  /*#__PURE__*/
  function (_Evented) {
    _inherits(Fullscreen, _Evented);

    _createClass(Fullscreen, [{
      key: "title",
      set: function set(value) {
        this._fs._controlContainer.firstChild.title = value;
      }
    }, {
      key: "fullscreen",
      get: function get() {
        return this._fs._fullscreen;
      }
    }]);

    function Fullscreen(options) {
      var _this;

      _classCallCheck(this, Fullscreen);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Fullscreen).call(this));
      _this._fs = new mapboxgl.FullscreenControl();
      _this.options = options;
      return _this;
    }

    _createClass(Fullscreen, [{
      key: "onFullscreenClick_Handler",
      value: function onFullscreenClick_Handler(ev) {
        if (!this.fullscreen) this.Emit("enterFullscreen", {});else this.Emit("exitFullscreen", {});
      }
    }, {
      key: "onAdd",
      value: function onAdd(map) {
        this._container = this._fs.onAdd(map);

        this._fs._controlContainer.firstChild.addEventListener("click", this.onFullscreenClick_Handler.bind(this));

        this._fs._controlContainer.firstChild.removeAttribute("aria-label");

        this.title = this.options.title;
        this._map = map;
        return this._container;
      }
    }, {
      key: "onRemove",
      value: function onRemove() {
        this._fs.onRemove();

        this._fs._container.parentNode.removeChild(this._fs._container);

        this._map = undefined;
      }
    }]);

    return Fullscreen;
  }(Evented);

  var Navigation =
  /*#__PURE__*/
  function (_Evented) {
    _inherits(Navigation, _Evented);

    _createClass(Navigation, [{
      key: "titleIn",
      set: function set(value) {
        this._n._zoomInButton.title = value;
      }
    }, {
      key: "titleOut",
      set: function set(value) {
        this._n._zoomOutButton.title = value;
      }
    }]);

    function Navigation(options) {
      var _this;

      _classCallCheck(this, Navigation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Navigation).call(this));
      _this._n = new mapboxgl.NavigationControl({
        showCompass: options.showCompass,
        showZoom: options.showZoom
      });
      _this.options = options;
      return _this;
    }

    _createClass(Navigation, [{
      key: "onFullscreenClick_Handler",
      value: function onFullscreenClick_Handler(ev) {
        if (!this.fullscreen) this.Emit("enterFullscreen", {});else this.Emit("exitFullscreen", {});
      }
    }, {
      key: "onAdd",
      value: function onAdd(map) {
        this._container = this._n.onAdd(map);

        this._n._zoomInButton.removeAttribute("aria-label");

        this._n._zoomOutButton.removeAttribute("aria-label");

        this.titleIn = this.options.titleIn;
        this.titleOut = this.options.titleOut;
        this._map = map;
        return this._container;
      }
    }, {
      key: "onRemove",
      value: function onRemove() {
        this._n.onRemove();

        this._n._container.parentNode.removeChild(this._n._container);

        this._map = undefined;
      }
    }]);

    return Navigation;
  }(Evented);

  var Popup =
  /*#__PURE__*/
  function (_Templated) {
    _inherits(Popup, _Templated);

    _createClass(Popup, [{
      key: "Content",
      set: function set(content) {
        this.content = content;
        Dom.Place(content, this.Node("body"));
      },
      get: function get() {
        return this.content;
      }
    }]);

    function Popup(css, container) {
      var _this;

      _classCallCheck(this, Popup);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Popup).call(this, container || document.body));
      _this.onBody_KeyUp_Bound = _this.onBody_KeyUp.bind(_assertThisInitialized(_this));
      _this.content = null;
      _this.h = null;

      _this.Node("close").addEventListener("click", _this.onBtnClose_Click.bind(_assertThisInitialized(_this)));

      if (css) Dom.AddCss(_this.Node("root"), css);

      _this.Node("root").addEventListener("click", _this.onModal_Click.bind(_assertThisInitialized(_this)));

      _this.SetStyle(0, "hidden");

      return _this;
    }

    _createClass(Popup, [{
      key: "SetStyle",
      value: function SetStyle(opacity, visibility) {
        this.Node("root").style.opacity = opacity;
        this.Node("root").style.visibility = visibility;
      }
    }, {
      key: "Show",
      value: function Show() {
        Util.DisableFocusable(Dom.Siblings(this.Node("root")), true);
        this.h = document.body.addEventListener("keyup", this.onBody_KeyUp_Bound);
        this.SetStyle(1, "visible");
        this.Emit("Show", {
          popup: this
        });
        this.Node("close").focus();
      }
    }, {
      key: "Hide",
      value: function Hide() {
        Util.DisableFocusable(Dom.Siblings(this.Node("root")), false);
        document.body.removeEventListener("keyup", this.onBody_KeyUp_Bound);
        this.SetStyle(0, "hidden");
        this.Emit("Hide", {
          popup: this
        });
      }
    }, {
      key: "onBody_KeyUp",
      value: function onBody_KeyUp(ev) {
        if (ev.keyCode == 27) this.Hide();
      }
    }, {
      key: "onModal_Click",
      value: function onModal_Click(ev) {
        this.Hide();
      }
    }, {
      key: "onBtnClose_Click",
      value: function onBtnClose_Click(ev) {
        this.Hide();
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='popup'>" + "<div class='popup-container'>" + "<div class='popup-header'>" + "<div class='popup-title' handle='title'></div>" + "<button class='close' handle='close'>Ã</button>" + "</div>" + "<div class='popup-body' handle='body'></div>" + "</div>" + "</div>";
      }
    }]);

    return Popup;
  }(Templated);

  var Menu =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Menu, _Control);

    function Menu(options) {
      var _this;

      _classCallCheck(this, Menu);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Menu).call(this, options));
      _this._container = _this.Node('root');
      _this.buttons = {};
      return _this;
    }

    _createClass(Menu, [{
      key: "AddButton",
      value: function AddButton(id, icon, title, hClick) {
        if (this.buttons[id]) throw new Error("Button already exists in menu.");
        var root = this.Node("root");
        var btn = Dom.Create("button", {
          "title": title,
          "aria-label": title,
          "type": "button",
          "className": "mapboxgl-ctrl-icon"
        }, root);
        var img = Dom.Create("img", {
          "src": icon
        }, btn);
        btn.addEventListener("click", hClick);
        this.buttons[id] = {
          node: btn
        };
        return btn;
      }
    }, {
      key: "AddPopupButton",
      value: function AddPopupButton(id, icon, title, widget, container) {
        var popup = new Popup("modal absolute popup-" + id, container);
        popup.Content = widget.Node("root");
        var button = this.AddButton(id, icon, title, function (ev) {
          popup.Show();
        });
        popup.On("Hide", this.OnPopupHide_Handler.bind(this, button));
        this.buttons[id].popup = popup;
        return popup;
      }
    }, {
      key: "Button",
      value: function Button(id) {
        return this.buttons[id] || null;
      }
    }, {
      key: "OnPopupHide_Handler",
      value: function OnPopupHide_Handler(button, ev) {
        button.focus();
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='maps-control mapboxgl-ctrl mapboxgl-ctrl-group'></div>";
      }
    }]);

    return Menu;
  }(Control);

  var Menu$1 =
  /*#__PURE__*/
  function (_Control) {
    _inherits(Menu, _Control);

    function Menu(options) {
      var _this;

      _classCallCheck(this, Menu);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Menu).call(this, options));
      _this.controls = {};

      for (var id in options.controls) {
        _this.AddControl(id, options.controls[id]);
      }

      _this._container = _this.Node('root');
      return _this;
    }

    _createClass(Menu, [{
      key: "AddControl",
      value: function AddControl(id, control) {
        if (this.controls.hasOwnProperty(id)) throw new Error("Control already exists in the group");
        this.controls[id] = control;
        Dom.Place(control._container, this.Node("root"));
      }
    }, {
      key: "Template",
      value: function Template() {
        return "<div handle='root' class='mapboxgl-ctrl mapboxgl-ctrl-group'></div>";
      }
    }]);

    return Menu;
  }(Control);

  var Map =
  /*#__PURE__*/
  function (_Evented) {
    _inherits(Map, _Evented);

    _createClass(Map, [{
      key: "Container",
      get: function get() {
        return this.map._container;
      }
    }, {
      key: "Center",
      get: function get() {
        return this.map.getCenter();
      },
      set: function set(value) {
        this.map.setCenter(value);
      }
    }, {
      key: "Zoom",
      get: function get() {
        return this.map.getZoom();
      },
      set: function set(value) {
        this.map.setZoom(value);
      }
    }, {
      key: "Style",
      get: function get() {
        return this.style;
      }
    }], [{
      key: "Token",
      set: function set(value) {
        mapboxgl.accessToken = value;
      },
      get: function get() {
        return mapboxgl.accessToken;
      }
    }]);

    function Map(options) {
      var _this;

      _classCallCheck(this, Map);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Map).call(this));
      _this.layers = [];
      _this.original = {};
      _this.style = options.style;
      _this.click = _this.OnLayerClick_Handler.bind(_assertThisInitialized(_this));
      _this.map = new mapboxgl.Map(options);

      _this.map.once('styledata', _this.OnceStyleData_Handler.bind(_assertThisInitialized(_this)));

      _this.WrapEvent('moveend', 'MoveEnd');

      _this.WrapEvent('zoomend', 'ZoomEnd');

      _this.WrapEvent('load', 'Load');

      return _this;
    }

    _createClass(Map, [{
      key: "AddSource",
      value: function AddSource(name, data) {
        this.map.addSource('odhf', data);
      }
    }, {
      key: "AddControl",
      value: function AddControl(control, location) {
        this.map.addControl(control, location);
      }
    }, {
      key: "InfoPopup",
      value: function InfoPopup(lngLat, html) {
        var popup = new mapboxgl.Popup({
          closeOnClick: true
        }).setLngLat(lngLat).setHTML(html).addTo(this.map);
      }
    }, {
      key: "Reset",
      value: function Reset(layers) {
        var _this2 = this;

        layers.forEach(function (l) {
          _this2.map.setPaintProperty(l, 'fill-color', _this2.original[l]);
        });
        this.original = {};
      }
    }, {
      key: "Choropleth",
      value: function Choropleth(layers, property, legend, opacity) {
        var _this3 = this;

        var classes = ['case'];
        legend.forEach(function (l) {
          var color = l.color.length == 3 ? "rgba(".concat(l.color.join(','), ",").concat(opacity, ")") : "rgba(".concat(l.color.join(','), ")");
          if (l.value) classes.push(l.value);
          classes.push(color);
        });
        layers.forEach(function (l) {
          _this3.original[l] = _this3.map.getPaintProperty(l, property);

          _this3.map.setPaintProperty(l, property, classes);
        });
      }
    }, {
      key: "ReorderLayers",
      value: function ReorderLayers(layers) {
        var _this4 = this;

        layers.forEach(function (l) {
          return _this4.map.moveLayer(l);
        });
      }
    }, {
      key: "GetLayer",
      value: function GetLayer(layer) {
        return this.map.getLayer(layer) || null;
      }
    }, {
      key: "ShowLayer",
      value: function ShowLayer(layer) {
        this.map.setLayoutProperty(layer, 'visibility', 'visible');
      }
    }, {
      key: "HideLayer",
      value: function HideLayer(layer) {
        this.map.setLayoutProperty(layer, 'visibility', 'none');
      }
    }, {
      key: "HideLayers",
      value: function HideLayers(layers) {
        var _this5 = this;

        layers.forEach(function (l) {
          return _this5.HideLayer(l);
        });
      }
    }, {
      key: "ShowLayers",
      value: function ShowLayers(layers) {
        var _this6 = this;

        layers.forEach(function (l) {
          return _this6.ShowLayer(l);
        });
      }
    }, {
      key: "FitBounds",
      value: function FitBounds(bounds, options) {
        this.map.fitBounds(bounds, options);
      }
    }, {
      key: "SetStyle",
      value: function SetStyle(style) {
        this.style = style;
        this.map.once('styledata', this.OnceStyleData_Handler.bind(this));
        this.map.setStyle(style);
      }
    }, {
      key: "SetClickableLayers",
      value: function SetClickableLayers(layers) {
        var _this7 = this;

        this.layers.forEach(function (l) {
          return _this7.map.off('click', l, _this7.click);
        });
        this.layers = layers;
        this.layers.forEach(function (l) {
          return _this7.map.on('click', l, _this7.click);
        });
      }
    }, {
      key: "OnceStyleData_Handler",
      value: function OnceStyleData_Handler(ev) {
        this.Emit('StyleChanged', ev);
      }
    }, {
      key: "OnLayerClick_Handler",
      value: function OnLayerClick_Handler(ev) {
        this.Emit('Click', ev);
      }
    }, {
      key: "WrapEvent",
      value: function WrapEvent(oEv, nEv) {
        var _this8 = this;

        var f = function f(ev) {
          return _this8.Emit(nEv, ev);
        };

        this.map.on(oEv, f);
      }
    }]);

    return Map;
  }(Evented);

  var Factory =
  /*#__PURE__*/
  function () {
    function Factory() {
      _classCallCheck(this, Factory);
    }

    _createClass(Factory, null, [{
      key: "Map",
      value: function Map$1(container, token, style, center, zoom) {
        Map.Token = token;
        return new Map({
          container: container,
          style: style,
          center: center,
          zoom: zoom
        });
      }
      /*
      static NavigationControl(showCompass, showZoom) {
      	return new mapboxgl.NavigationControl({ showCompass:showCompass, showZoom:showZoom });
      }
      */

    }, {
      key: "NavigationControl",
      value: function NavigationControl(showCompass, showZoom, titleIn, titleOut) {
        return new Navigation({
          showCompass: showCompass,
          showZoom: showZoom,
          titleIn: titleIn,
          titleOut: titleOut
        });
      }
    }, {
      key: "FullscreenControl",
      value: function FullscreenControl(title) {
        return new Fullscreen({
          title: title
        });
      }
    }, {
      key: "GeolocateControl",
      value: function GeolocateControl() {
        return new mapboxgl.GeolocateControl({
          positionOptions: {
            enableHighAccuracy: true
          },
          trackUserLocation: true
        });
      }
    }, {
      key: "ScaleControl",
      value: function ScaleControl(units) {
        return new mapboxgl.ScaleControl({
          maxWidth: 80,
          unit: units
        });
      }
    }, {
      key: "AttributionControl",
      value: function AttributionControl() {
        return new mapboxgl.AttributionControl({
          compact: true
        });
      } // TODO : LegendControl requires too many parameters

    }, {
      key: "LegendControl",
      value: function LegendControl(legend, title, banner, subtitle) {
        return new Legend({
          legend: legend,
          title: title,
          banner: banner,
          subtitle: subtitle
        });
      }
    }, {
      key: "TocControl",
      value: function TocControl(toc) {
        return new Toc({
          toc: toc
        });
      }
    }, {
      key: "OpacityControl",
      value: function OpacityControl(opacity) {
        return new Legend$1({
          opacity: opacity
        });
      }
    }, {
      key: "DownloadControl",
      value: function DownloadControl(link) {
        return new Download({
          link: link
        });
      }
    }, {
      key: "MapsListControl",
      value: function MapsListControl(maps) {
        return new MapsList({
          maps: maps
        });
      }
    }, {
      key: "BookmarksControl",
      value: function BookmarksControl(items) {
        return new Bookmarks({
          items: items
        });
      }
    }, {
      key: "MenuControl",
      value: function MenuControl(items) {
        return new Menu({
          items: items
        });
      }
    }, {
      key: "SearchControl",
      value: function SearchControl(items, placeholder, title) {
        return new Search({
          items: items,
          placeholder: placeholder,
          title: title
        });
      }
    }, {
      key: "Group",
      value: function Group(controls) {
        return new Menu$1({
          controls: controls
        });
      }
    }]);

    return Factory;
  }();

  var Store =
  /*#__PURE__*/
  function () {
    function Store() {
      _classCallCheck(this, Store);
    }

    _createClass(Store, null, [{
      key: "Map",
      get: function get() {
        return localStorage.getItem("lode-map") || "trans";
      },
      set: function set(value) {
        localStorage.setItem("lode-map", value);
      }
    }, {
      key: "Lat",
      get: function get() {
        return localStorage.getItem("lode-center-lat") || 45.4215;
      },
      set: function set(value) {
        localStorage.setItem("lode-center-lat", value);
      }
    }, {
      key: "Lng",
      get: function get() {
        return localStorage.getItem("lode-center-lng") || -75.6972;
      },
      set: function set(value) {
        localStorage.setItem("lode-center-lng", value);
      }
    }, {
      key: "Zoom",
      get: function get() {
        return localStorage.getItem("lode-zoom") || 11;
      },
      set: function set(value) {
        localStorage.setItem("lode-zoom", value);
      }
    }, {
      key: "Opacity",
      get: function get() {
        return localStorage.getItem("lode-opacity") || 0.75;
      },
      set: function set(value) {
        localStorage.setItem("lode-opacity", value);
      }
    }, {
      key: "Layer",
      get: function get() {
        return localStorage.getItem("lode-layer") || "da";
      },
      set: function set(value) {
        localStorage.setItem("lode-layer", value);
      }
    }]);

    return Store;
  }();

  var ProxApp =
  /*#__PURE__*/
  function () {
    function ProxApp(config) {
      _classCallCheck(this, ProxApp);

      this.config = config;
      this.current = this.config.maps[Store.Map]; // this.data = this.CSVtoJson(config.data);

      if (!this.current) this.current = Util.FirstProperty(this.config.maps);
      this.AddMap();
      this.AddSearch();
      this.AddBaseControls();
      this.AddGroup();
      this.AddMenu();
    }

    _createClass(ProxApp, [{
      key: "AddMap",
      value: function AddMap() {
        var token = "pk.eyJ1IjoiZGVpbC1sZWlkIiwiYSI6ImNrMzZxODNvNTAxZjgzYm56emk1c3doajEifQ.H5CJ3maS0ZuxX_7QTgz1kg";
        this.map = Factory.Map("map", token, this.current.Style, [Store.Lng, Store.Lat], Store.Zoom); // Hooking up all events

        this.map.On("StyleChanged", this.OnMapStyleChanged_Handler.bind(this));
        this.map.On("MoveEnd", this.OnMapMoveEnd_Handler.bind(this));
        this.map.On("ZoomEnd", this.OnMapZoomEnd_Handler.bind(this));
        this.map.On("Click", this.OnMapClick_Handler.bind(this)); // this.map.On("Load", this.OnMapLoad_Handler.bind(this));
      }
    }, {
      key: "AddBaseControls",
      value: function AddBaseControls() {
        var fullscreen = Factory.FullscreenControl(Core.Nls("FullScreen_Title"));
        var navigation = Factory.NavigationControl(false, true, Core.Nls("Navigation_ZoomIn_Title"), Core.Nls("Navigation_ZoomOut_Title"));
        var scale = Factory.ScaleControl("metric");
        this.map.AddControl(fullscreen, "top-left");
        this.map.AddControl(navigation, "top-left");
        this.map.AddControl(scale);
      }
    }, {
      key: "AddSearch",
      value: function AddSearch() {
        var search = Factory.SearchControl(this.config.search.items, Core.Nls("Search_Placeholder"), Core.Nls("Search_Title")); // Add top-left search bar

        this.map.AddControl(search, "top-left");
        search.On("Change", this.OnSearchChange_Handler.bind(this));
        search.Node("typeahead").Node("input").focus();
      }
    }, {
      key: "AddGroup",
      value: function AddGroup() {
        // Top-right group for legend, etc.		
        this.group = {
          legend: Factory.LegendControl(this.current.Legend, null, this.current.Title, this.current.Subtitle),
          download: Factory.DownloadControl(null)
        };
        this.map.AddControl(Factory.Group(this.group));
      }
    }, {
      key: "AddMenu",
      value: function AddMenu() {
        // Top-left menu below navigation
        var bookmarks = Factory.BookmarksControl(this.config.bookmarks);
        this.menu = Factory.MenuControl();
        this.map.AddControl(this.menu, "top-left");
        this.menu.AddButton("home", "assets/globe.png", Core.Nls("Home_Title"), this.OnHomeClick_Handler.bind(this));
        this.menu.AddPopupButton("bookmarks", "assets/bookmarks.png", Core.Nls("Bookmarks_Title"), bookmarks, this.map.Container);
        bookmarks.On("BookmarkSelected", this.OnBookmarkSelected_Handler.bind(this));
      }
    }, {
      key: "OnHomeClick_Handler",
      value: function OnHomeClick_Handler(ev) {
        this.map.FitBounds([[-173.457, 41.846], [-17.324, 75.848]]);
      }
    }, {
      key: "OnBookmarkSelected_Handler",
      value: function OnBookmarkSelected_Handler(ev) {
        this.menu.Button("bookmarks").popup.Hide();
        this.map.FitBounds(ev.item.extent, {
          animate: false
        });
      }
    }, {
      key: "OnListSelected_Handler",
      value: function OnListSelected_Handler(ev) {
        this.menu.Button("maps").popup.Hide();
        Store.Map = ev.id;
        this.map.SetStyle(ev.map.Style);
        this.current = ev.map;
        this.group.legend.Reload(this.current.Legend, this.current.Title, this.current.Subtitle);
      }
    }, {
      key: "OnMapStyleChanged_Handler",
      value: function OnMapStyleChanged_Handler(ev) {
        this.map.SetClickableLayers(this.current.LayerIDs);
        this.map.Choropleth(this.current.LayerIDs, 'circle-color', this.current.Legend, 1);
      }
    }, {
      key: "OnMapMoveEnd_Handler",
      value: function OnMapMoveEnd_Handler(ev) {
        Store.Lat = this.map.Center.lat;
        Store.Lng = this.map.Center.lng;
      }
    }, {
      key: "OnMapZoomEnd_Handler",
      value: function OnMapZoomEnd_Handler(ev) {
        Store.Zoom = this.map.Zoom;
      }
    }, {
      key: "OnMapClick_Handler",
      value: function OnMapClick_Handler(ev) {
        if (ev.features.length == 0) return;
        var html = Other.HTMLize(ev.features[0].properties, this.current.Fields, Core.Nls("Map_Not_Available"));
        this.map.InfoPopup(ev.lngLat, html);
      }
    }, {
      key: "OnSearchChange_Handler",
      value: function OnSearchChange_Handler(ev) {
        var legend = [{
          color: this.config.search.color,
          value: ["==", ["get", this.config.search.field], ev.item.id]
        }, {
          color: [255, 255, 255, 0]
        }];
        this.map.Choropleth([this.config.search.layer], 'line-color', legend);
        this.map.FitBounds(ev.item.extent, {
          padding: 30,
          animate: false
        });
      }
      /*
      OnMapLoad_Handler(ev) {
      	this.map.AddSource('odhf', this.data);
      	
      	
      	this.map.map.addLayer({
      		id: 'clusters',
      		type: 'circle',
      		source: 'odhf',
      		filter: ['has', 'point_count'],
      		paint: {
      			// Use step expressions (https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-step)
      			// with three steps to implement three types of circles:
      			//   * Blue, 20px circles when point count is less than 100
      			//   * Yellow, 30px circles when point count is between 100 and 750
      			//   * Pink, 40px circles when point count is greater than or equal to 750
      			'circle-color': ['step', ['get', 'point_count'], '#51bbd6',	100, '#f1f075',	750, '#f28cb1'],
      			'circle-radius': ['step', ['get', 'point_count'], 20, 100, 	30, 750, 40]
      		}
      	});
      }
      
      CSVtoJson(csv) {		
      	var data = Util.ParseCsv(csv);
      	
      	var json = {
      		"type": "geojson",
      		"data" : { "type" : "FeatureCollection", "features" : [] },
      		"cluster" : true,
      		"clusterMaxZoom": 14, 	// Max zoom to cluster points on
      		"clusterRadius": 50 		// Radius of each cluster when clustering points (defaults to 50)
      	}
      	
      	var fields = data.shift();
      	
      	data.forEach(d => {
      		var f = { "type": "Feature", "properties":{}, "geometry":{ "type": "Point", "coordinates":[] }};
      		
      		for (var i = 0; iÂ <Â fields.length; i++) {
      			if (fields[i] == "longitude") f.geometry.coordinates[0] = +d[i];
      			
      			else if (fields[i] == "latitude") f.geometry.coordinates[1] = +d[i];
      
      			else f.properties[fields[i]] = (d[i] == "" ? null : d[i]);
      		}
      		
      		json.data.features.push(f);
      	});
      	
      	return json;
      }
      */

    }]);

    return ProxApp;
  }();

  Net.JSON("./config/config.nls.json").then(function (value) {
    Core.locale = document.documentElement.lang || "en";
    Core.nls = value.result;
    var p1 = Net.JSON("./config/config.applications.json");
    p1.then(Start);
  });

  function Start(results) {
    var id = Net.GetUrlParameter("app");
    var maps = results.result;
    var app = maps["base"];
    var defs = app.map(function (m) {
      return Net.JSON(m);
    });
    var config = {};
    var p1 = Promise.all(defs).then(function (values) {
      config.maps = {};
      values.forEach(function (v) {
        return config.maps[v.result.id] = Configuration.FromJSON(v.result);
      });
    });
    var p2 = Net.JSON("./config/config.bookmarks.json").then(function (value) {
      config.bookmarks = value.result.items;
    });
    var p3 = Net.JSON("./config/config.search.json").then(function (value) {
      config.search = value.result;
    });
    /*
    var p4 = Net.Request(`./data/data.csv`).then(value => {
    	config.data = value.result;
    });
    */
    // Promise.all([p1, p2, p3, p4]).then(results => {

    Promise.all([p1, p2, p3]).then(function (results) {
      var app = new ProxApp(config);
    });
  }

}());
